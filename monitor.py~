#!/usr/bin/env python3
# −*− coding:utf-8 −*−

import sys, os, time, argparse
import numpy as np
import pyqtgraph as pg
import matplotlib as mpl
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.uic import *
from processing import Processing
from multithread import Worker

class Data_Monitor(QMainWindow):
    '''
    A GUI for monitoring the latest data file under a designated directory, then inspecting it in both time and frequency domains
    '''

    fgcolor = "#23373B"
    bgcolor = "#FAFAFA"
    blue    = "#113285"
    green   = "#1B813E"
    orange  = "#E98B2A"
    red     = "#AB3B3A"
    data_file = '' # empty initial file
    lut = (mpl.colormaps.get_cmap("viridis")(np.linspace(0, 1, 256))[:,:3] * 255).astype(np.dtype("u1"))
    pg.setConfigOptions(background=bgcolor, foreground=fgcolor, antialias=True, imageAxisOrder="row-major")
    def font_label(self, string): return "<span style=font-family:RobotoCondensed;font-size:14pt>" + string + "</span>"

    def __init__(self, directory=None, win_len=2000, n_average=10, puyuan_new=False):
        '''
        paint the user interface and establish the signal-socket connections
        directory:      location to be sought for data files
        '''
        super().__init__()
        loadUi("monitor.ui", self) # the .ui file is generated by the Qt creator
        self.thread_pool = QThreadPool()

        # Handle the directory if no argument is provided or if the provided argument was empty/invalid
        if directory:
            self.directory = directory
        else:
            print("No directory provided as argument, using default.")
            self.directory = '/home/imsexp/data/'
        self.win_len = win_len
        self.n_average = n_average
        self.puyuan_new = puyuan_new
        self.logarithm = self.rLog.isChecked()
        self.manual = self.rManual.isChecked()
        self.draw_plots()
        self.build_connections()

    def draw_plots(self):
        '''
        draw the time signals separately in in-phase and quadrature parts, also the frequency signals separately in 1d and 2d forms
        '''
        # time plots --- in-phase
        self.plot_i = self.gTimeSeries.addPlot(0, 0)
        self.plot_i.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_i.setLabels(left=self.font_label("In-Phase"), bottom=self.font_label("Time [s]"))
        self.plot_i.setRange(xRange=(0, 1), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q = self.gTimeSeries.addPlot(1, 0)
        self.plot_q.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_q.setLabels(left=self.font_label("Quadrature"), bottom=self.font_label("Time [s]"))
        self.plot_q.setRange(xRange=(0, 1), yRange=(-1, 1))
        # dummy data for frequency plots
        self.frequencies = np.array([-1, 0, 1])
        self.times_f = np.array([0, 1])
        self.spectrogram = np.array([[1, 1]])
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.plot((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame],
                pen=self.orange, fillLevel=self.fill_level, fillBrush=self.orange+"80")
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"),
                left=self.font_label("Power Spectral Density"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrum.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # frequency plots --- spectrogram
        self.img = pg.ImageItem(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.img.setLookupTable(self.lut)
        self.gSpectrogram.addItem(self.img)
        self.gSpectrogram.setLabels(left=self.font_label("Time [s]"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrogram.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # file list -- replace QFileSystemModel with QStandardItemModel
        self.mFileList = QStandardItemModel(0,1)
        self.mFileList.setHeaderData(0, Qt.Horizontal, "Filename")
        self.vFileList.setModel(self.mFileList)
        self.wParaTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.wParaTable.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def build_connections(self):
        '''
        build the signal-slot connections
        '''
        # bind time plots
        def update_range_i():
            self.plot_i.setRange(self.plot_q.getViewBox().viewRect(), padding=0)
        def update_range_q():
            self.plot_q.setRange(self.plot_i.getViewBox().viewRect(), padding=0)
        self.plot_i.sigRangeChanged.connect(update_range_q)
        self.plot_q.sigRangeChanged.connect(update_range_i)
        # bind frequency plots
        self.indicator = self.gSpectrogram.addLine(y=self.times_f[0], bounds=[self.times_f[0], self.times_f[-1]],
                pen=self.bgcolor, hoverPen=self.red, movable=True)
        def on_dragged(line):
            pos = line.value()
            self.frame = int((pos - self.times_f[0]) / (self.times_f[1] - self.times_f[0]))
            self.frame -= 1 if self.frame == self.times_f.size-1 else 0
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
            self.gSpectrum.setTitle(self.font_label("Frame # {:d}".format(self.frame)))
        self.indicator.sigPositionChanged.connect(on_dragged)
        def update_range_spectrum():
            self.gSpectrum.setXRange(*self.gSpectrogram.getViewBox().viewRange()[0], padding=0)
        def update_range_spectrogram():
            self.gSpectrogram.setXRange(*self.gSpectrum.getViewBox().viewRange()[0], padding=0)
        self.gSpectrum.sigRangeChanged.connect(update_range_spectrogram)
        self.gSpectrogram.sigRangeChanged.connect(update_range_spectrum)
        # read coordinates at the cursor in time plots
        def on_moved_i(point):
            if self.plot_i.sceneBoundingRect().contains(point):
                coords = self.plot_i.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, i = {:.5g}".format(coords.x(), coords.y()))
        def on_moved_q(point):
            if self.plot_q.sceneBoundingRect().contains(point):
                coords = self.plot_q.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, q = {:.5g}".format(coords.x(), coords.y()))
        self.plot_i.scene().sigMouseMoved.connect(on_moved_i)
        self.plot_q.scene().sigMouseMoved.connect(on_moved_q)
        # read coordinates at the cursor in frequency plots
        self.crosshair_h = pg.InfiniteLine(pos=self.fill_level, angle=0, pen=self.fgcolor)
        self.crosshair_v = pg.InfiniteLine(pos=0, angle=90, pen=self.fgcolor)
        self.gSpectrum.addItem(self.crosshair_h, ignoreBounds=True)
        self.gSpectrum.addItem(self.crosshair_v, ignoreBounds=True)
        def on_moved_spectrum(point):
            if self.gSpectrum.sceneBoundingRect().contains(point):
                coords = self.gSpectrum.getViewBox().mapSceneToView(point)
                self.crosshair_h.setValue(coords.y())
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}".format(coords.x(), self.indicator.value(), coords.y()))
        self.gSpectrum.scene().sigMouseMoved.connect(on_moved_spectrum)
        def on_moved_spectrogram(point):
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(coords.x(), self.indicator.value(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseMoved.connect(on_moved_spectrogram)
        def on_clicked(event):
            point = event.scenePos()
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.indicator.setValue(coords.y())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(self.crosshair_v.value(), coords.y(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseClicked.connect(on_clicked)
        # toggle the linear or logarithmic scale, auto or manual refresh mode
        def on_toggled_scale():
            self.logarithm = self.rLog.isChecked()
            if self.logarithm:
                self.spectrogram = np.log10(self.spectrogram)
            else:
                self.spectrogram = np.power(10, self.spectrogram)
            self.img.setImage(self.spectrogram)
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
        self.rLin.toggled.connect(on_toggled_scale)
        # recreate file list for NAS reader at Linux server
        self.file_filters = ["*.wvd", "*.tiq", "*.TIQ", "*.tdms", "*.data"]
        self._current_files_info = {}
        # timer configure for refreshing file list
        def on_polling_timeout():
            scan_and_update_model()
            if not self.manual:
                last_file(None)
            else:
                pass
        def scan_and_update_model():
            '''scaning directory, update QStandardItemModel'''
            current_scan_files_on_disk = {} # {filepath: {'size': int, 'mtime': QDateTime}}
            try:
                # iter directory
                for entry_name in os.listdir(self.directory):
                    filepath = os.path.join(self.directory, entry_name)
                    if os.path.isfile(filepath):
                        matched = False
                        for pattern in self.file_filters:
                            if QDir().match(pattern, entry_name):
                                matched = True
                                break
                        if not matched:
                            continue
                        # acquire file infos
                        file_info = QFileInfo(filepath)
                        if not file_info.exists():
                            return
                        current_scan_files_on_disk[filepath] = {
                            'size': file_info.size(), 
                            'mtime': file_info.lastModified()}
            except OSError as e:
                print(f"Can't scan directory '{self.directory}': {e}")
                return
            # remove files not exist 
            files_to_remove = []
            for filepath in self._current_files_info.keys():
                if filepath not in current_scan_files_on_disk:
                    files_to_remove.append(filepath)
            for filepath in files_to_remove:
                self._current_files_info.pop(filepath)
            # update file info and status
            for filepath, disk_info in current_scan_files_on_disk.items():
                current_size = disk_info['size']
                current_mtime = disk_info['mtime']
                if filepath not in self._current_files_info:
                    self._current_files_info[filepath] = {
                        'size': current_size,
                        'mtime': current_mtime,
                        'status': 'new'}
                else:
                    cached_info = self._current_files_info[filepath]
                    old_size = cached_info['size']
                    old_mtime = cached_info['mtime']
                    if current_size > old_size:
                        cached_info['size'] = current_size
                        cached_info['mtime'] = current_mtime
                        cached_info['status'] = 'growing'
                    elif current_size < old_size:
                        cached_info['size'] = current_size
                        cached_info['mtime'] = current_mtime
                        cached_info['status'] = 'new'
                    elif current_size == old_size and current_mtime != old_mtime:
                        cached_info['size'] = current_size
                        cached_info['mtime'] = current_mtime
                        cached_info['status'] = 'new'
                    else:
                        cached_info['status'] = 'stable'

            # arrange model
            current_model_data = []
            for filepath, info in self._current_files_info.items():
                current_model_data.append((filepath, os.path.basename(filepath), info['mtime'], info['status']))
            current_model_data.sort(key=lambda x: x[2], reverse=True)
            self.mFileList.clear()
            self.mFileList.setHeaderData(0, Qt.Horizontal, "filename")
            for filepath, filename, mtime_qdatetime, status in current_model_data:
                item = QStandardItem(filename)
                item.setData(filepath, Qt.UserRole)
                item.setData(mtime_qdatetime, Qt.UserRole+1)
                item.setData(status, Qt.UserRole+2)
                if status != 'stable':
                    item.setForeground(QColor("crimson"))
                self.mFileList.appendRow(item)

        self.refresh_interval_ms = 2000 # [ms]
        self.polling_timer = QTimer(self)
        self.polling_timer.timeout.connect(on_polling_timeout)
        
        def on_toggled_refresh():
            self.manual = self.rManual.isChecked()
            if self.manual:
                self.vFileList.activated.connect(selected_file)
            else:
                self.vFileList.clearSelection()
                try:
                    self.vFileList.activated.disconnect(selected_file)
                except:
                    pass
                last_file(None)
            if not self.polling_timer.isActive():
                self.polling_timer.start(self.refresh_interval_ms)
        scan_and_update_model()
        self.rAuto.setChecked(True)
        self.rAuto.toggled.connect(on_toggled_refresh)
        # select a file for analysis
        def selected_file(model_index):
            if not model_index.isValid():
                return
            item = self.mFileList.itemFromIndex(model_index)
            if item:
                filepath = item.data(Qt.UserRole)
                if filepath:
                    self.prepare_data(os.path.basename(filepath))
        def last_file(model_index):
            if self.mFileList.rowCount() == 0:
                print("DEBUG: no valid file")
                return
            next_filepath_to_process = None
            for row in range(self.mFileList.rowCount()):
                item = self.mFileList.item(row, 0)
                if item:
                    filepath = item.data(Qt.UserRole)
                    status = item.data(Qt.UserRole+2)
                    if filepath and status == 'stable':
                        next_filepath_to_process = filepath
                        break
            if not next_filepath_to_process:
                return
            self.prepare_data(os.path.basename(next_filepath_to_process))
        if not self.rAuto.isChecked():
            self.rAuto.setChecked(True)
        else:
            on_toggled_refresh()
        # Ctrl+W or Ctrl+Q to quit the application
        shortcutW = QShortcut(QKeySequence.Close, self)
        shortcutQ = QShortcut(QKeySequence.Quit, self)
        shortcutW.activated.connect(self.close)
        shortcutQ.activated.connect(self.close)

    def prepare_data(self, data_file):
        '''
        load the data in time domain from disk, and compute the frequency data
        '''
        if self.data_file == data_file: # duplicate work is inadvisable
            return
        else:
            self.data_file = data_file
        processing = Processing(self.directory+self.data_file, self.puyuan_new)
        # extract acquisition parameters
        self.file_name = processing.fname
        self.timestamp = str(processing.date_time)
        self.ref_level = processing.ref_level # dBm
        self.sampling_rate = processing.sampling_rate / 1e3 # kHz
        self.n_sample = processing.n_sample # IQ pairs
        self.span = processing.span
        self.center_frequency = processing.center_frequency
        # data in time domain, on a spin-off thread
        worker_t = Worker(super(Processing, processing).diagnosis, n_point=10**5, draw=False)
        worker_t.signals.result.connect(self.redraw_time_plots)
        self.thread_pool.start(worker_t)
        # data in frequency domain, on another thread
        if self.n_sample <= 2.7e8: # number of IQ pairs <= 62.5M (data filesize <= 500MB), showing the full spectrum
            worker_f = Worker(processing.time_average_2d, window_length=self.win_len, n_frame=-1,
                    padding_ratio=1, n_offset=0, n_average=self.n_average, estimator='p', window="kaiser", beta=14)
        else:
            worker_f = Worker(processing.time_average_2d, window_length=self.win_len, n_frame=-1,
                    padding_ratio=1, n_offset=0, n_average=int(self.n_sample/self.win_len/3125), estimator='p', window="kaiser", beta=14)
        worker_f.signals.result.connect(self.redraw_frequency_plots)
        self.thread_pool.start(worker_f)
        # status bar changes only if two threads both terminate
        self.statusbar.showMessage("updating...")
        self.working_threads = 2
        def wait_for_finish(): 
            if self.working_threads == 0:
                return self.statusbar.clearMessage()
            else:
                QTimer.singleShot(100, wait_for_finish)
        wait_for_finish()

    def redraw_time_plots(self, args):
        '''
        redraw the in-phase and quadrature plots, and update the parameter table
        '''
        self.times_t, self.iqs = args # s, V
        # acquisition parameters
        self.wParaTable.setItem(0, 1, QTableWidgetItem(self.file_name))
        self.wParaTable.setItem(1, 1, QTableWidgetItem(self.timestamp))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level)))
        self.wParaTable.setItem(3, 1, QTableWidgetItem("{:g} kHz".format(self.sampling_rate)))
        self.wParaTable.setItem(4, 1, QTableWidgetItem("{:,d}".format(self.n_sample)))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level) 
                                                   if self.ref_level is not None and not np.isnan(self.ref_level) 
                                                   else "N/A"))
        # time plots --- in-phase
        self.plot_i.listDataItems()[0].setData(self.times_t, np.real(self.iqs))
        self.plot_i.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q.listDataItems()[0].setData(self.times_t, np.imag(self.iqs))
        self.plot_q.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        self.working_threads -= 1

    def redraw_frequency_plots(self, args):
        '''
        redraw the frequency spectrum and spectrogram
        '''
        frequencies, self.times_f, spectrogram = args[:3] # kHz, s, V^2/kHz
        self.times_f = (self.times_f[:-1] + self.times_f[1:])/2
        spectrogram = np.abs(spectrogram[1:] - spectrogram[:-1])
        index_l = np.argmin(np.abs(frequencies+self.span/2e3))
        index_r = np.argmin(np.abs(frequencies-self.span/2e3)) + 1
        self.frequencies = frequencies[index_l:index_r] # kHz
        spectrogram = spectrogram[:,index_l:index_r-1] # V^2/kHz
        self.spectrogram = np.log10(spectrogram) if self.logarithm else spectrogram
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
        self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"), bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrum.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.fill_level, np.max(self.spectrogram[self.frame])))
        # frequency plots --- spectrogram
        self.img.setImage(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.gSpectrogram.setLabels(bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrogram.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.times_f[0], self.times_f[-1]))
        # reset markers
        self.crosshair_h.setValue(self.fill_level)
        self.crosshair_v.setValue(0)
        self.indicator.setValue(self.times_f[0])
        self.indicator.setBounds([self.times_f[0], self.times_f[-1]])
        self.working_threads -= 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Data Monitor GUI")
    parser.add_argument("directory", nargs='?', default=None, help="Input directory path")
    parser.add_argument("--win_len", "-wl", type=int, default=2000, help="Window length of FFT (default: 2000)")
    parser.add_argument("--n_average", "-avg", type=int, default=10, help="Average of each frame (default: 10)")
    parser.add_argument("--puyuan_new", "-pn", type=bool, default=False, help="Using puyuan's new device or not (default: False)")

    args = parser.parse_args()
    app = QApplication(sys.argv)
    
    if args.directory:
        data_monitor = Data_Monitor(
                directory=args.directory,
                win_len=args.win_len,
                n_average=args.n_average,
                puyuan_new=args.puyuan_new)
    else:
        print("Usage: python3 monitor.py [directory_path] [--win_len WINDOW_LENGTH] [--n_average N_AVERAGE] [--puyuan_new True/False]")
        data_monitor = Data_Monitor()

    data_monitor.show()
    sys.exit(app.exec())
