#!/usr/bin/env python3
# −*− coding:utf-8 −*−

import sys, os, time
import numpy as np
import pyqtgraph as pg
import matplotlib as mpl
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.uic import *
from processing import Processing
from multithread import Worker

class FileCompletionChecker(QObject):
    file_ready = pyqtSignal(str)
    check_interval = 200
    stability_checks = 3

    def __init__(self, target_filePath, parent=None):
        super().__init__(parent)
        self._target_filePath = target_filePath
        self._last_size = -1
        self._stable_count = 0
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._check_file_status)

    def start_checking(self):
        self._last_size = -1
        self._stable_count = 0
        self._timer.start(self.check_interval)

    def stop_checking(self):
        self._timer.stop()

    def _check_file_status(self):
        if not os.path.exists(self._target_filePath):
            self._last_size = -1
            self._stable_count = 0
            return
        current_size = os.path.getsize(self._target_filePath)

        if current_size == self._last_size:
            self._stable_count += 1
            if self._stable_count >= self.stability_checks:
                self.stop_checking()
                self.file_ready.emit(os.path.basename(self._target_filePath))
        else:
            self._last_size = current_size
            self._stable_count = 0
        

class Data_Monitor(QMainWindow):
    '''
    A GUI for monitoring the latest data file under a designated directory, then inspecting it in both time and frequency domains
    '''

    fgcolor = "#23373B"
    bgcolor = "#FAFAFA"
    blue    = "#113285"
    green   = "#1B813E"
    orange  = "#E98B2A"
    red     = "#AB3B3A"
    data_file = '' # empty initial file
    lut = (mpl.colormaps.get_cmap("viridis")(np.linspace(0, 1, 256))[:,:3] * 255).astype(np.dtype("u1"))
    pg.setConfigOptions(background=bgcolor, foreground=fgcolor, antialias=True, imageAxisOrder="row-major")
    def font_label(self, string): return "<span style=font-family:RobotoCondensed;font-size:14pt>" + string + "</span>"

    def __init__(self, directory=None):
        '''
        paint the user interface and establish the signal-socket connections
        directory:      location to be sought for data files
        '''
        super().__init__()
        loadUi("monitor.ui", self) # the .ui file is generated by the Qt creator
        self.thread_pool = QThreadPool()

        # Handle the directory if no argument is provided or if the provided argument was empty/invalid
        if directory:
            self.directory = directory
        else:
            print("No directory provided as argument, using default.")
            self.directory = '/home/imsexp/data/'
        self.logarithm = self.rLog.isChecked()
        self.manual = self.rManual.isChecked()
        self.draw_plots()
        self.build_connections()

    def draw_plots(self):
        '''
        draw the time signals separately in in-phase and quadrature parts, also the frequency signals separately in 1d and 2d forms
        '''
        # time plots --- in-phase
        self.plot_i = self.gTimeSeries.addPlot(0, 0)
        self.plot_i.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_i.setLabels(left=self.font_label("In-Phase"), bottom=self.font_label("Time [s]"))
        self.plot_i.setRange(xRange=(0, 1), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q = self.gTimeSeries.addPlot(1, 0)
        self.plot_q.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_q.setLabels(left=self.font_label("Quadrature"), bottom=self.font_label("Time [s]"))
        self.plot_q.setRange(xRange=(0, 1), yRange=(-1, 1))
        # dummy data for frequency plots
        self.frequencies = np.array([-1, 0, 1])
        self.times_f = np.array([0, 1])
        self.spectrogram = np.array([[1, 1]])
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.plot((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame],
                pen=self.orange, fillLevel=self.fill_level, fillBrush=self.orange+"80")
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"),
                left=self.font_label("Power Spectral Density"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrum.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # frequency plots --- spectrogram
        self.img = pg.ImageItem(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.img.setLookupTable(self.lut)
        self.gSpectrogram.addItem(self.img)
        self.gSpectrogram.setLabels(left=self.font_label("Time [s]"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrogram.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # file list -- replace QFileSystemModel with QStandardItemModel
        self.mFileList = QStandardItemModel(0,1)
        self.mFileList.setHeaderData(0, Qt.Horizontal, "Filename")
        self.vFileList.setModel(self.mFileList)
        self.wParaTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.wParaTable.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def build_connections(self):
        '''
        build the signal-slot connections
        '''
        # bind time plots
        def update_range_i():
            self.plot_i.setRange(self.plot_q.getViewBox().viewRect(), padding=0)
        def update_range_q():
            self.plot_q.setRange(self.plot_i.getViewBox().viewRect(), padding=0)
        self.plot_i.sigRangeChanged.connect(update_range_q)
        self.plot_q.sigRangeChanged.connect(update_range_i)
        # bind frequency plots
        self.indicator = self.gSpectrogram.addLine(y=self.times_f[0], bounds=[self.times_f[0], self.times_f[-1]],
                pen=self.bgcolor, hoverPen=self.red, movable=True)
        def on_dragged(line):
            pos = line.value()
            self.frame = int((pos - self.times_f[0]) / (self.times_f[1] - self.times_f[0]))
            self.frame -= 1 if self.frame == self.times_f.size-1 else 0
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
            self.gSpectrum.setTitle(self.font_label("Frame # {:d}".format(self.frame)))
        self.indicator.sigPositionChanged.connect(on_dragged)
        def update_range_spectrum():
            self.gSpectrum.setXRange(*self.gSpectrogram.getViewBox().viewRange()[0], padding=0)
        def update_range_spectrogram():
            self.gSpectrogram.setXRange(*self.gSpectrum.getViewBox().viewRange()[0], padding=0)
        self.gSpectrum.sigRangeChanged.connect(update_range_spectrogram)
        self.gSpectrogram.sigRangeChanged.connect(update_range_spectrum)
        # read coordinates at the cursor in time plots
        def on_moved_i(point):
            if self.plot_i.sceneBoundingRect().contains(point):
                coords = self.plot_i.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, i = {:.5g}".format(coords.x(), coords.y()))
        def on_moved_q(point):
            if self.plot_q.sceneBoundingRect().contains(point):
                coords = self.plot_q.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, q = {:.5g}".format(coords.x(), coords.y()))
        self.plot_i.scene().sigMouseMoved.connect(on_moved_i)
        self.plot_q.scene().sigMouseMoved.connect(on_moved_q)
        # read coordinates at the cursor in frequency plots
        self.crosshair_h = pg.InfiniteLine(pos=self.fill_level, angle=0, pen=self.fgcolor)
        self.crosshair_v = pg.InfiniteLine(pos=0, angle=90, pen=self.fgcolor)
        self.gSpectrum.addItem(self.crosshair_h, ignoreBounds=True)
        self.gSpectrum.addItem(self.crosshair_v, ignoreBounds=True)
        def on_moved_spectrum(point):
            if self.gSpectrum.sceneBoundingRect().contains(point):
                coords = self.gSpectrum.getViewBox().mapSceneToView(point)
                self.crosshair_h.setValue(coords.y())
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}".format(coords.x(), self.indicator.value(), coords.y()))
        self.gSpectrum.scene().sigMouseMoved.connect(on_moved_spectrum)
        def on_moved_spectrogram(point):
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(coords.x(), self.indicator.value(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseMoved.connect(on_moved_spectrogram)
        def on_clicked(event):
            point = event.scenePos()
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.indicator.setValue(coords.y())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(self.crosshair_v.value(), coords.y(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseClicked.connect(on_clicked)
        # toggle the linear or logarithmic scale, auto or manual refresh mode
        def on_toggled_scale():
            self.logarithm = self.rLog.isChecked()
            if self.logarithm:
                self.spectrogram = np.log10(self.spectrogram)
            else:
                self.spectrogram = np.power(10, self.spectrogram)
            self.img.setImage(self.spectrogram)
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
        self.rLin.toggled.connect(on_toggled_scale)
        # recreate file list for NAS reader at Linux server
        self.file_filters = ["*.wvd", "*.tiq", "*.TIQ", "*.tdms", "*.data"]
        self._current_files_info = {} # format: {filepath: (size, mtime)}
        # timer configure for refreshing file list
        def on_polling_timeout():
            scan_and_update_model()
            if not self.manual:
                last_file(None)
            else:
                pass
        def scan_and_update_model():
            '''scaning directory, update QStandardItemModel'''
            current_scan_files_info = {}
            found_files_in_dir = set()
            try:
                # iter directory
                for entry_name in os.listdir(self.directory):
                    filepath = os.path.join(self.directory, entry_name)
                    if os.path.isfile(filepath):
                        matched = False
                        for pattern in self.file_filters:
                            if QDir().match(pattern, entry_name):
                                matched = True
                                break
                        if not matched:
                            continue
                        # acquire file infos
                        file_info = QFileInfo(filepath)
                        size = file_info.size() 
                        mtime_qdatetime = file_info.lastModified()
                        current_scan_files_info[filepath] = (size, mtime_qdatetime)
                        found_files_in_dir.add(filepath)
            except OSError as e:
                print(f"Can't scan directory '{self.directory}': {e}")
                return
            existing_items = {} # {filepath: QStandardItem}
            for row in range(self.mFileList.rowCount()):
                item = self.mFileList.item(row, 0)
                if item:
                    existing_items[item.data(Qt.UserRole)] = item
            new_items_to_add = []
            updated_items = []
            # comparing old infos with the new, update model
            files_to_remove = []
            for filepath in existing_items.keys():
                if filepath not in found_files_in_dir:
                    files_to_remove.append(filepath)
            for filepath in files_to_remove:
                existing_items.pop(filepath)
                self._current_files_info.pop(filepath, None)
            # modifing the files
            for filepath, (size, mtime_qdatetime) in current_scan_files_info.items():
                if filepath not in existing_items:
                    filename_item = QStandardItem(os.path.basename(filepath))
                    filename_item.setData(filepath, Qt.UserRole)
                    filename_item.setData(mtime_qdatetime, Qt.UserRole+1)
                    new_items_to_add.append((filepath, filename_item))
                    self._current_files_info[filepath] = (size, mtime_qdatetime)
                else:
                    # checking if file is modified (size or mtime)
                    old_size, old_mtime = self._current_files_info[filepath]
                    if old_size != size or old_mtime != mtime_qdatetime:
                        item = existing_items[filepath]
                        item.setText(os.path.basename(filepath))
                        item.setData(mtime_qdatetime, Qt.UserRole+1)
                        updated_items.append((filepath, item))
                        self._current_files_info[filepath] = (size, mtime_qdatetime)
            # arrange model
            all_display_items = []
            for filepath, (size, mtime_qdatetime) in self._current_files_info.items():
                all_display_items.append((filepath, os.path.basename(filepath), mtime_qdatetime))
            all_display_items.sort(key=lambda x: x[2], reverse=True)
            self.mFileList.clear()
            self.mFileList.setHeaderData(0, Qt.Horizontal, "filename")
            for filepath, filename, mtime_qdatetime in all_display_items:
                item = QStandardItem(filename)
                item.setData(filepath, Qt.UserRole)
                item.setData(mtime_qdatetime, Qt.UserRole+1)
                self.mFileList.appendRow(item)

        self.refresh_interval_ms = 2000 # [ms]
        self.polling_timer = QTimer(self)
        self.polling_timer.timeout.connect(on_polling_timeout)
        
        def on_toggled_refresh():
            self.manual = self.rManual.isChecked()
            if self.manual:
                self.vFileList.activated.connect(selected_file)
                if self.active_file_checker:
                    self.active_file_checker.stop_checking()
                    self.active_file_checker = None
            else:
                self.vFileList.clearSelection()
                try:
                    self.vFileList.activated.disconnect(selected_file)
                except:
                    pass
                last_file(None)
            if not self.polling_timer.isActive():
                self.polling_timer.start(self.refresh_interval_ms)
        self.active_file_checker = None
        self.manual = False
        scan_and_update_model()
        self.rAuto.setChecked(True)
        self.rAuto.toggled.connect(on_toggled_refresh)
        # select a file for analysis
        def selected_file(model_index):
            item = self.mFileList.itemFromIndex(model_index)
            if item:
                filepath = item.data(Qt.UserRole)
                if filepath:
                    if self.active_file_checker:
                        self.active_file_checker.stop_checking()
                        self.active_file_checker = None
            self.prepare_data(os.path.basename(filepath))
        def last_file(model_index):
            if self.active_file_checker:
                self.active_file_checker.stop_checking()
                self.active_file_checker = None
            if self.mFileList == 0:
                return
            latest_filepath = None
            latest_mtime = 0
            for row in range(self.mFileList.rowCount()):
                item = self.mFileList.item(row, 0)
                if item:
                    path = item.data(Qt.UserRole)
                    if path:
                        file_info = QFileInfo(path)
                        if file_info.lastModified().toSecsSinceEpoch() > latest_mtime:
                            latest_mtime = file_info.lastModified().toSecsSinceEpoch()
                            latest_filepath = path
            if not latest_filepath:
                return
            latest_filename = os.path.basename(latest_filepath)
            self.active_file_checker = FileCompletionChecker(latest_filepath)
            self.active_file_checker.file_ready.connect(self.prepare_data)
            self.active_file_checker.start_checking()
        if not self.rAuto.isChecked():
            self.rAuto.setChecked(True)
        else:
            on_toggled_refresh()
        # Ctrl+W or Ctrl+Q to quit the application
        shortcutW = QShortcut(QKeySequence.Close, self)
        shortcutQ = QShortcut(QKeySequence.Quit, self)
        shortcutW.activated.connect(self.close)
        shortcutQ.activated.connect(self.close)

    def prepare_data(self, data_file):
        '''
        load the data in time domain from disk, and compute the frequency data
        '''
        if self.data_file == data_file: # duplicate work is inadvisable
            return
        else:
            self.data_file = data_file
        processing = Processing(self.directory+self.data_file)
        # extract acquisition parameters
        self.file_name = processing.fname
        self.timestamp = str(processing.date_time)
        self.ref_level = processing.ref_level # dBm
        self.sampling_rate = processing.sampling_rate / 1e3 # kHz
        self.n_sample = processing.n_sample # IQ pairs
        self.span = processing.span
        self.center_frequency = processing.center_frequency
        # data in time domain, on a spin-off thread
        worker_t = Worker(super(Processing, processing).diagnosis, n_point=10**5, draw=False)
        worker_t.signals.result.connect(self.redraw_time_plots)
        self.thread_pool.start(worker_t)
        # data in frequency domain, on another thread
        if self.n_sample <= 2.7e8: # number of IQ pairs <= 62.5M (data filesize <= 500MB), showing the full spectrum
            worker_f = Worker(processing.time_average_2d, window_length=2000, n_frame=-1,
                    padding_ratio=1, n_offset=0, n_average=10, estimator='p', window="kaiser", beta=14)
        else:
            worker_f = Worker(processing.time_average_2d, window_length=2000, n_frame=-1,
                    padding_ratio=1, n_offset=0, n_average=int(self.n_sample/window_length/3125), estimator='p', window="kaiser", beta=14)
        worker_f.signals.result.connect(self.redraw_frequency_plots)
        self.thread_pool.start(worker_f)
        # status bar changes only if two threads both terminate
        self.statusbar.showMessage("updating...")
        self.working_threads = 2
        def wait_for_finish(): 
            if self.working_threads == 0:
                return self.statusbar.clearMessage()
            else:
                QTimer.singleShot(100, wait_for_finish)
        wait_for_finish()

    def redraw_time_plots(self, args):
        '''
        redraw the in-phase and quadrature plots, and update the parameter table
        '''
        self.times_t, self.iqs = args # s, V
        # acquisition parameters
        self.wParaTable.setItem(0, 1, QTableWidgetItem(self.file_name))
        self.wParaTable.setItem(1, 1, QTableWidgetItem(self.timestamp))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level)))
        self.wParaTable.setItem(3, 1, QTableWidgetItem("{:g} kHz".format(self.sampling_rate)))
        self.wParaTable.setItem(4, 1, QTableWidgetItem("{:,d}".format(self.n_sample)))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level) 
                                                   if self.ref_level is not None and not np.isnan(self.ref_level) 
                                                   else "N/A"))
        # time plots --- in-phase
        self.plot_i.listDataItems()[0].setData(self.times_t, np.real(self.iqs))
        self.plot_i.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q.listDataItems()[0].setData(self.times_t, np.imag(self.iqs))
        self.plot_q.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        self.working_threads -= 1

    def redraw_frequency_plots(self, args):
        '''
        redraw the frequency spectrum and spectrogram
        '''
        frequencies, self.times_f, spectrogram = args[:3] # kHz, s, V^2/kHz
        self.times_f = (self.times_f[:-1] + self.times_f[1:])/2
        spectrogram = np.abs(spectrogram[1:] - spectrogram[:-1])
        index_l = np.argmin(np.abs(frequencies+self.span/2e3))
        index_r = np.argmin(np.abs(frequencies-self.span/2e3)) + 1
        self.frequencies = frequencies[index_l:index_r] # kHz
        spectrogram = spectrogram[:,index_l:index_r-1] # V^2/kHz
        self.spectrogram = np.log10(spectrogram) if self.logarithm else spectrogram
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
        self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"), bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrum.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.fill_level, np.max(self.spectrogram[self.frame])))
        # frequency plots --- spectrogram
        self.img.setImage(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.gSpectrogram.setLabels(bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrogram.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.times_f[0], self.times_f[-1]))
        # reset markers
        self.crosshair_h.setValue(self.fill_level)
        self.crosshair_v.setValue(0)
        self.indicator.setValue(self.times_f[0])
        self.indicator.setBounds([self.times_f[0], self.times_f[-1]])
        self.working_threads -= 1


if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    if len(sys.argv) > 1:
        input_directory = sys.argv[1]
        data_monitor = Data_Monitor(directory=input_directory)
    else:
        print("Usage: python3 monitor.py [directory_path]")
        data_monitor = Data_Monitor()

    data_monitor.show()
    sys.exit(app.exec())
