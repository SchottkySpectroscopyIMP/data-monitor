#!/usr/bin/env python3
# −*− coding:utf-8 −*−

import sys, os, time, argparse
import numpy as np
import pyqtgraph as pg
import matplotlib as mpl
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.uic import *
from preprocessing import Preprocessing
from psd_array import psd_array_welch 
from multithread import Worker

class FileCompletionChecker(QObject):
    file_ready = pyqtSignal(str)
    check_interval = 200
    stability_checks = 3

    def __init__(self, target_filePath, parent=None):
        super().__init__(parent)
        self._target_filePath = target_filePath
        self._last_size = -1
        self._stable_count = 0
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._check_file_status)

    def start_checking(self):
        self._last_size = -1
        self._stable_count = 0
        self._timer.start(self.check_interval)

    def stop_checking(self):
        self._timer.stop()

    def _check_file_status(self):
        if not os.path.exists(self._target_filePath):
            self._last_size = -1
            self._stable_count = 0
            return
        current_size = os.path.getsize(self._target_filePath)

        if current_size == self._last_size:
            self._stable_count += 1
            if self._stable_count >= self.stability_checks:
                self.stop_checking()
                dirname, filename = os.path.split(self._target_filePath)
                self.file_ready.emit(filename)
        else:
            self._last_size = current_size
            self._stable_count = 0
        

class Data_Monitor(QMainWindow):
    '''
    A GUI for monitoring the latest data file under a designated directory, then inspecting it in both time and frequency domains
    '''

    fgcolor = "#23373B"
    bgcolor = "#FAFAFA"
    blue    = "#113285"
    green   = "#1B813E"
    orange  = "#E98B2A"
    red     = "#AB3B3A"
    data_file = '' # empty initial file
    lut = (mpl.colormaps.get_cmap("viridis")(np.linspace(0, 1, 256))[:,:3] * 255).astype(np.dtype("u1"))
    pg.setConfigOptions(background=bgcolor, foreground=fgcolor, antialias=True, imageAxisOrder="row-major")
    def font_label(self, string): return "<span style=font-family:RobotoCondensed;font-size:14pt>" + string + "</span>"

    def __init__(self, directory=None, win_len=2000, n_average=10, puyuan_new=False, channel_id=["ch1", "ch2", "ch3", "ch4"]):
        '''
        paint the user interface and establish the signal-socket connections
        directory:      location to be sought for data files
        '''
        super().__init__()
        loadUi("monitor.ui", self) # the .ui file is generated by the Qt creator
        self.thread_pool = QThreadPool()

        # Handle the directory if no argument is provided or if the provided argument was empty/invalid
        if directory:
            self.directory = directory
        else:
            print("No directory provided as argument, using default.")
            self.directory = '/home/imsexp/data/'
        self.win_len = win_len
        self.n_average = n_average
        self.puyuan_new = puyuan_new
        self.channel_id = channel_id
        self.logarithm = self.rLog.isChecked()
        self.manual = self.rManual.isChecked()
        self.draw_plots()
        self.build_connections()

    def draw_plots(self):
        '''
        draw the time signals separately in in-phase and quadrature parts, also the frequency signals separately in 2d and 2d forms
        '''
        # time plots --- in-phase
        self.plot_i = self.gTimeSeries.addPlot(0, 0)
        self.plot_i.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_i.setLabels(left=self.font_label("In-Phase"), bottom=self.font_label("Time [s]"))
        self.plot_i.setRange(xRange=(0, 1), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q = self.gTimeSeries.addPlot(1, 0)
        self.plot_q.plot([0, 1], [0, 0], pen=self.blue)
        self.plot_q.setLabels(left=self.font_label("Quadrature"), bottom=self.font_label("Time [s]"))
        self.plot_q.setRange(xRange=(0, 1), yRange=(-1, 1))
        # dummy data for frequency plots
        self.frequencies = np.array([-1, 0, 1])
        self.times_f = np.array([0, 1])
        self.spectrogram = np.array([[1, 1]])
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.plot((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame],
                pen=self.orange, fillLevel=self.fill_level, fillBrush=self.orange+"80")
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"),
                left=self.font_label("Power Spectral Density"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrum.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # frequency plots --- spectrogram
        self.img = pg.ImageItem(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.img.setLookupTable(self.lut)
        self.gSpectrogram.addItem(self.img)
        self.gSpectrogram.setLabels(left=self.font_label("Time [s]"), bottom=self.font_label("Frequency − ___ MHz [kHz]"))
        self.gSpectrogram.setRange(xRange=(self.frequencies[0], self.frequencies[-1]), yRange=(self.times_f[0], self.times_f[-1]))
        # file list
        self.mFileList = QFileSystemModel()
        self.mFileList.setFilter(QDir.Files)
        if self.puyuan_new and len(self.channel_id) < 4:
            self.file_filters = ["*.wvd", "*.tiq", "*.TIQ", "*.tdms"]
            for _ch_id in self.channel_id:
                self.file_filters.append("*{:}_*.data".format(_ch_id))
        else:
            self.file_filters = ["*.wvd", "*.tiq", "*.TIQ", "*.tdms", "*.data"]
        self.mFileList.setNameFilters(self.file_filters)
        self.mFileList.setNameFilterDisables(False)
        self.mFileList.sort(3, Qt.DescendingOrder) # sort by the fourth column, i.e. modified time
        self.vFileList.setModel(self.mFileList)
        self.vFileList.setRootIndex(self.mFileList.setRootPath(self.directory))
        # acquisition parameters
        self.wParaTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.wParaTable.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def build_connections(self):
        '''
        build the signal-slot connections
        '''
        # bind time plots
        def update_range_i():
            self.plot_i.setRange(self.plot_q.getViewBox().viewRect(), padding=0)
        def update_range_q():
            self.plot_q.setRange(self.plot_i.getViewBox().viewRect(), padding=0)
        self.plot_i.sigRangeChanged.connect(update_range_q)
        self.plot_q.sigRangeChanged.connect(update_range_i)
        # bind frequency plots
        self.indicator = self.gSpectrogram.addLine(y=self.times_f[0], bounds=[self.times_f[0], self.times_f[-1]],
                pen=self.bgcolor, hoverPen=self.red, movable=True)
        def on_dragged(line):
            pos = line.value()
            self.frame = int((pos - self.times_f[0]) / (self.times_f[1] - self.times_f[0]))
            self.frame -= 1 if self.frame == self.times_f.size-1 else 0
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
            self.gSpectrum.setTitle(self.font_label("Frame # {:d}".format(self.frame)))
        self.indicator.sigPositionChanged.connect(on_dragged)
        def update_range_spectrum():
            self.gSpectrum.setXRange(*self.gSpectrogram.getViewBox().viewRange()[0], padding=0)
        def update_range_spectrogram():
            self.gSpectrogram.setXRange(*self.gSpectrum.getViewBox().viewRange()[0], padding=0)
        self.gSpectrum.sigRangeChanged.connect(update_range_spectrogram)
        self.gSpectrogram.sigRangeChanged.connect(update_range_spectrum)
        # read coordinates at the cursor in time plots
        def on_moved_i(point):
            if self.plot_i.sceneBoundingRect().contains(point):
                coords = self.plot_i.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, i = {:.5g}".format(coords.x(), coords.y()))
        def on_moved_q(point):
            if self.plot_q.sceneBoundingRect().contains(point):
                coords = self.plot_q.getViewBox().mapSceneToView(point)
                self.statusbar.showMessage("t = {:.5g} s, q = {:.5g}".format(coords.x(), coords.y()))
        self.plot_i.scene().sigMouseMoved.connect(on_moved_i)
        self.plot_q.scene().sigMouseMoved.connect(on_moved_q)
        # read coordinates at the cursor in frequency plots
        self.crosshair_h = pg.InfiniteLine(pos=self.fill_level, angle=0, pen=self.fgcolor)
        self.crosshair_v = pg.InfiniteLine(pos=0, angle=90, pen=self.fgcolor)
        self.gSpectrum.addItem(self.crosshair_h, ignoreBounds=True)
        self.gSpectrum.addItem(self.crosshair_v, ignoreBounds=True)
        def on_moved_spectrum(point):
            if self.gSpectrum.sceneBoundingRect().contains(point):
                coords = self.gSpectrum.getViewBox().mapSceneToView(point)
                self.crosshair_h.setValue(coords.y())
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}".format(coords.x(), self.indicator.value(), coords.y()))
        self.gSpectrum.scene().sigMouseMoved.connect(on_moved_spectrum)
        def on_moved_spectrogram(point):
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.crosshair_v.setValue(coords.x())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(coords.x(), self.indicator.value(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseMoved.connect(on_moved_spectrogram)
        def on_clicked(event):
            point = event.scenePos()
            if self.gSpectrogram.sceneBoundingRect().contains(point):
                coords = self.gSpectrogram.getViewBox().mapSceneToView(point)
                self.indicator.setValue(coords.y())
                self.statusbar.showMessage("δf = {:.5g} kHz, t = {:.5g} s, psd = {:.5g}"
                        .format(self.crosshair_v.value(), coords.y(), self.crosshair_h.value()))
        self.gSpectrogram.scene().sigMouseClicked.connect(on_clicked)
        # toggle the linear or logarithmic scale, auto or manual refresh mode
        def on_toggled_scale():
            self.logarithm = self.rLog.isChecked()
            if self.logarithm:
                self.spectrogram = np.log10(self.spectrogram)
            else:
                self.spectrogram = np.power(10, self.spectrogram)
            self.img.setImage(self.spectrogram)
            self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
            self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
            self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
            current_range = self.gSpectrum.getViewBox().viewRange()[0]
            self.gSpectrum.autoRange()
            self.gSpectrum.setXRange(*current_range, padding=0)
        self.rLin.toggled.connect(on_toggled_scale)
        def on_toggled_refresh():
            self.manual = self.rManual.isChecked()
            if self.manual:
                self.vFileList.activated.connect(selected_file)
                self.mFileList.rowsInserted.disconnect(last_file)
                self.mFileList.rowsRemoved.disconnect(last_file)
                if self.active_file_checker:
                    self.active_file_checker.stop_checking()
                    self.active_file_checker = None
            else:
                self.vFileList.clearSelection()
                self.vFileList.activated.disconnect(selected_file)
                self.mFileList.rowsInserted.connect(last_file)
                self.mFileList.rowsRemoved.connect(last_file)
                last_file(None)
        self.active_file_checker = None
        self.rAuto.toggled.connect(on_toggled_refresh)
        # select a file for analysis
        def selected_file(model_index):
            if self.active_file_checker:
                self.active_file_checker.stop_checking()
                self.active_file_checker = None
            self.prepare_data(model_index.data())
        def last_file(model_index):
            if self.active_file_checker:
                self.active_file_checker.stop_checking()
                self.active_file_checker = None
            lastest_filename = model_index.child(0,0).data()
            lastest_filePath = self.directory + lastest_filename
            self.active_file_checker = FileCompletionChecker(lastest_filePath)
            self.active_file_checker.file_ready.connect(self.prepare_data)
            self.active_file_checker.start_checking()

        if self.manual:
            self.vFileList.activated.connect(selected_file)
        else:
            self.mFileList.rowsInserted.connect(last_file)
            self.mFileList.rowsRemoved.connect(last_file)
        # Ctrl+W or Ctrl+Q to quit the application
        shortcutW = QShortcut(QKeySequence.Close, self)
        shortcutQ = QShortcut(QKeySequence.Quit, self)
        shortcutW.activated.connect(self.close)
        shortcutQ.activated.connect(self.close)

    def prepare_data(self, data_file):
        '''
        load the data in time domain from disk, and compute the frequency data
        '''
        if self.data_file == data_file: # duplicate work is inadvisable
            return
        else:
            self.data_file = data_file
        bud = Preprocessing(self.directory+self.data_file, self.puyuan_new)
        # extract acquisition parameters
        self.file_name = bud.fname
        self.timestamp = str(bud.date_time)
        self.ref_level = bud.ref_level if os.path.splitext(self.data_file)[1] != '.data' else 0 # dBm
        overlap_ratio = 0.67 if os.path.splitext(self.data_file)[1] != '.data' else 0
        self.sampling_rate = bud.sampling_rate / 1e3 # kHz
        self.n_sample = bud.n_sample # IQ pairs
        self.span = bud.span # Hz
        self.center_frequency = bud.center_frequency # Hz
        # data in time domain, on a spin-off thread
        worker_t = Worker(bud.diagnosis, n_point=10**5, draw=False)
        worker_t.signals.result.connect(self.redraw_time_plots)
        self.thread_pool.start(worker_t)
        # data in frequency domain, on another thread
        if self.n_sample <= 2.7e8: # number of IQ pairs <= 62.5M (data filesize <= 500MB), showing the full spectrum
            worker_f = Worker(psd_array_welch, bud=bud, offset=0, window_length=self.win_len, 
                    n_average=self.n_average, overlap_ratio=overlap_ratio, n_frame=-1, n_hop=0, padding_ratio=0, window="kaiser", beta=14)
        else:
            print("file too large, set n_average = {:d}".format(int(self.n_sample/self.win_len/3125)))
            worker_f = Worker(psd_array_welch, bud=bud, offset=0, window_length=self.win_len, 
                    n_average=int(self.n_sample/self.win_len/3125), overlap_ratio=overlap_ratio, n_frame=-1, n_hop=0, padding_ratio=0, window="kaiser", beta=14)
        worker_f.signals.result.connect(self.redraw_frequency_plots)
        self.thread_pool.start(worker_f)
        # status bar changes only if two threads both terminate
        self.statusbar.showMessage("updating...")
        self.working_threads = 2
        def wait_for_finish(): 
            if self.working_threads == 0:
                return self.statusbar.clearMessage()
            else:
                QTimer.singleShot(100, wait_for_finish)
        wait_for_finish()

    def redraw_time_plots(self, args):
        '''
        redraw the in-phase and quadrature plots, and update the parameter table
        '''
        self.times_t, self.iqs = args # s, V
        # acquisition parameters
        self.wParaTable.setItem(0, 1, QTableWidgetItem(self.file_name))
        self.wParaTable.setItem(1, 1, QTableWidgetItem(self.timestamp))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level)))
        self.wParaTable.setItem(3, 1, QTableWidgetItem("{:g} kHz".format(self.sampling_rate)))
        self.wParaTable.setItem(4, 1, QTableWidgetItem("{:,d}".format(self.n_sample)))
        self.wParaTable.setItem(2, 1, QTableWidgetItem("{:g} dBm".format(self.ref_level) 
                                                   if self.ref_level is not None and not np.isnan(self.ref_level) 
                                                   else "N/A"))
        # time plots --- in-phase
        self.plot_i.listDataItems()[0].setData(self.times_t, np.real(self.iqs))
        self.plot_i.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        # time plots --- quadrature
        self.plot_q.listDataItems()[0].setData(self.times_t, np.imag(self.iqs))
        self.plot_q.setRange(xRange=(self.times_t[0], self.times_t[-1]), yRange=(-1, 1))
        self.working_threads -= 1

    def redraw_frequency_plots(self, args):
        '''
        redraw the frequency spectrum and spectrogram
        '''
        frequencies, self.times_f, spectrogram = args[:3] # Hz, s, V^2/kHz
        self.times_f = (self.times_f[:-1] + self.times_f[1:])/2
        spectrogram = np.abs(spectrogram[1:] - spectrogram[:-1])
        index_l = np.argmin(np.abs(frequencies/1e3+self.span/2e3))
        index_r = np.argmin(np.abs(frequencies/1e3-self.span/2e3)) + 1
        self.frequencies = frequencies[index_l:index_r]/1e3 # kHz
        spectrogram = spectrogram[:,index_l:index_r-1]*1e-3 # V^2/kHz
        self.spectrogram = np.log10(spectrogram) if self.logarithm else spectrogram
        self.frame = 0
        self.fill_level = np.floor(np.min(self.spectrogram[self.frame])) if self.logarithm else 0
        # frequency plots --- spectrum
        self.gSpectrum.listDataItems()[0].setData((self.frequencies[:-1]+self.frequencies[1:])/2, self.spectrogram[self.frame])
        self.gSpectrum.listDataItems()[0].setFillLevel(self.fill_level)
        self.gSpectrum.setLabels(title=self.font_label("Frame # 0"), bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrum.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.fill_level, np.max(self.spectrogram[self.frame])))
        # frequency plots --- spectrogram
        self.img.setImage(self.spectrogram)
        self.img.setRect(QRectF(-(self.frequencies[-1]-self.frequencies[0])/2, self.times_f[0],
            self.frequencies[-1]-self.frequencies[0], self.times_f[-1]-self.times_f[0]))
        self.gSpectrogram.setLabels(bottom=self.font_label("Frequency − {:g} MHz [kHz]".format(self.center_frequency/1e6)))
        self.gSpectrogram.setRange(xRange=(-self.span/2e3, self.span/2e3), yRange=(self.times_f[0], self.times_f[-1]))
        # reset markers
        self.crosshair_h.setValue(self.fill_level)
        self.crosshair_v.setValue(0)
        self.indicator.setValue(self.times_f[0])
        self.indicator.setBounds([self.times_f[0], self.times_f[-1]])
        self.working_threads -= 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Data Monitor GUI")
    parser.add_argument("directory", nargs='?', default=None, help="Input directory path")
    parser.add_argument("--win_len", "-wl", type=int, default=2000, help="Window length of FFT (default: 2000)")
    parser.add_argument("--n_average", "-avg", type=int, default=10, help="Average of each frame (default: 10)")
    parser.add_argument("--puyuan_new", "-pn", type=bool, default=False, help="Using puyuan's new device or not (default: False)")
    parser.add_argument("--channel_id", "-c", type=str, nargs='+', default=["ch1", "ch2", "ch3", "ch4"], help="Displaying puyuan's special channels, separated by space (e.g. --channel_id ch1 ch2)")

    args = parser.parse_args()
    app = QApplication(sys.argv)
    
    if args.directory:
        data_monitor = Data_Monitor(
                directory=args.directory,
                win_len=args.win_len,
                n_average=args.n_average,
                puyuan_new=args.puyuan_new,
                channel_id=args.channel_id)
    else:
        print("Usage: python3 monitor.py [directory_path] [--win_len WINDOW_LENGTH] [--n_average N_AVERAGE] [--puyuan_new True/False] [--channel_id ch1 ch2 ...")
        data_monitor = Data_Monitor()

    data_monitor.show()
    sys.exit(app.exec())
